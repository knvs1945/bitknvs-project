{"version":3,"file":"jobs.js","sourceRoot":"","sources":["../../src/jobs.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;GAaG;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,4CAA6B;AAC7B,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAClB,CAAC,EACD,OAAO,EAAE,CAAC,oBAAoB,KAAK,UAAU,CAAC,CAAC;IAC7C,EAAE,CAAC,oBAAoB,EAAE;IAC3B,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,CACnB,CAAA;AAED,6CAA6C;AAChC,QAAA,IAAI;AACf,wCAAwC;AACxC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACV,qBAAqB;IACvB,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;QAClB,uCAAuC;QACzC,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;YACjC,uCAAuC;YACzC,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;gBAC9C,gBAAgB;gBAClB,CAAC,CAAC,EAAE,CAAA","sourcesContent":["/**\n * Heuristic to find a nice ergonomic number of jobs to do in parallel by\n * default.\n *\n * If we use ALL the available CPUs, then that can actually make tests more\n * flaky in some cases, because things will start to drag.\n *\n * Especially, if there's a ton of CPUs, like on a hosted CI system, we don't\n * want to flood the system too aggressively, since memory may be constrained.\n * But, we do want to parallelize tests quite a bit by default, as this can\n * speed things up considerably.\n *\n * @module\n */\n\nimport * as os from 'node:os'\nconst max = Math.max(\n  1,\n  typeof os.availableParallelism === 'function' ?\n    os.availableParallelism()\n  : os.cpus().length,\n)\n\n// If we only have a few CPUs, ok, use em all\nexport const jobs =\n  // it's the only one, we have to use it.\n  max <= 1 ? 1\n    // leave one CPU free\n  : max <= 4 ? max - 1\n    // if we have up to 16, use 3/4 of them\n  : max <= 16 ? Math.ceil(max * 0.75)\n    // if we have up to 32, use 1/2 of them\n  : max <= 32 ? Math.max(12, Math.ceil(max * 0.5))\n    // top out at 16\n  : 16\n"]}